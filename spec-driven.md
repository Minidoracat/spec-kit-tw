# 規範驅動開發（SDD）

## 權力反轉

幾十年來，程式碼一直是王者。規範服務於程式碼——它們是我們搭建的鷹架，一旦編碼的「真正工作」開始，就會被丟棄。我們編寫 PRD 來指導開發，建立設計文件來告知實作，繪製圖表來視覺化架構。但這些總是從屬於程式碼本身。程式碼就是真理。其他一切都只是良好的意圖。程式碼是真理的來源，隨著它的發展，規範很少能跟上步伐。由於資產（程式碼）和實作是一體的，如果不試圖從程式碼建構，就很難有並行實作。

規範驅動開發（SDD）顛覆了這種權力結構。規範不為程式碼服務——程式碼為規範服務。產品需求文件（PRD）不是實作的指南；它是產生實作的來源。技術計畫不是告知編碼的文件；它們是產生程式碼的精確定義。這不是對軟體建構方式的漸進式改進。這是對驅動開發內容的根本性重新思考。

規範與實作之間的差距自軟體誕生以來就一直困擾著軟體開發。我們試圖透過更好的文件、更詳細的需求、更嚴格的流程來彌合這一差距。這些方法之所以失敗，是因為它們認為差距是不可避免的。它們試圖縮小差距，但從未消除它。SDD 透過使規範及其從規範產生的具體實作計畫可執行來消除差距。當規範到實作計畫產生程式碼時，就沒有差距——只有轉換。

這種轉換現在之所以可能，是因為 AI 能夠理解和實作複雜的規範，並建立詳細的實作計畫。但是沒有結構的原始 AI 生成會產生混亂。SDD 透過精確、完整和明確的規範及後續實作計畫來提供這種結構，足以產生工作系統。規範成為主要工件。程式碼成為其在特定語言和框架中的表達（作為實作計畫的實作）。

在這個新世界中，維護軟體意味著演進規範。開發團隊的意圖用自然語言（「**意圖驅動開發**」）、設計資產、核心原則和其他指導方針來表達。開發的**通用語言**移動到更高層次，而程式碼是最後一英里的方法。

除錯意味著修復產生錯誤程式碼的規範及其實作計畫。重構意味著為了清晰而重組。整個開發工作流程圍繞規範作為中心真理來源重新組織，實作計畫和程式碼作為持續再生的輸出。使用新功能更新應用程式或建立新的並行實作，因為我們是有創造力的生物，意味著重新審視規範並建立新的實作計畫。因此這個過程是 0 -> 1, (1', ..), 2, 3, N。

開發團隊專注於他們的創造力、實驗性和批判性思維。

## SDD 工作流程實踐

工作流程從一個想法開始——通常是模糊和不完整的。透過與 AI 的迭代對話，這個想法成為一個全面的 PRD。AI 提出澄清問題，識別邊界情況，並幫助定義精確的驗收標準。在傳統開發中可能需要幾天會議和文件的工作，在幾小時的專注規範工作中就完成了。這改變了傳統的 SDLC——需求和設計成為持續活動而不是離散階段。這支援**團隊流程**，即團隊審查的規範被表達和版本控制，在分支中建立，並合併。

當產品經理更新驗收標準時，實作計畫會自動標記受影響的技術決策。當架構師發現更好的模式時，PRD 會更新以反映新的可能性。

在整個規範過程中，研究代理收集關鍵上下文。他們調查函式庫相容性、效能基準和安全影響。組織約束被自動發現和應用——您公司的資料庫標準、身份驗證要求和部署策略無縫整合到每個規範中。

從 PRD，AI 產生將需求對應到技術決策的實作計畫。每個技術選擇都有記錄的基本原理。每個架構決策都可追溯到特定需求。在整個過程中，一致性驗證持續提高品質。AI 分析規範的模糊性、矛盾和差距——不是作為一次性關卡，而是作為持續改進。

一旦規範及其實作計畫足夠穩定，就可以開始程式碼產生，但它們不必「完整」。早期產生可能是探索性的——測試規範在實踐中是否有意義。領域概念成為資料模型。使用者故事成為 API 端點。驗收場景成為測試。這透過規範將開發和測試合併——測試場景不是在程式碼之後編寫，它們是產生實作和測試的規範的一部分。

反饋循環擴展到初始開發之外。生產指標和事件不僅觸發熱修復——它們還為下一次再生更新規範。效能瓶頸成為新的非功能性需求。安全漏洞成為影響所有未來產生的約束。規範、實作和營運現實之間的這種迭代舞蹈是真正理解出現的地方，也是傳統 SDLC 轉變為持續演進的地方。

## 為什麼 SDD 現在重要

三大趨勢使 SDD 不僅可能而且必要：

首先，AI 能力已經達到一個門檻，自然語言規範可以可靠地產生工作程式碼。這不是關於取代開發者——而是透過自動化從規範到實作的機械轉換來放大他們的效果。它可以放大探索和創造力，它可以輕鬆支援「重新開始」，它支援加法減法和批判性思維。

其次，軟體複雜性繼續呈指數級增長。現代系統整合了數十個服務、框架和相依性。透過手動流程保持所有這些部分與原始意圖一致變得越來越困難。SDD 透過規範驅動的產生提供系統性一致性。框架可能會演進以提供 AI 優先支援，而不是人類優先支援，或者圍繞可重用元件進行架構設計。

第三，變化的速度加快。需求現在比以往任何時候變化得更快。轉向不再例外——它是預期的。現代產品開發需要基於使用者反饋、市場條件和競爭壓力進行快速迭代。傳統開發將這些變化視為干擾。每次轉向都需要手動傳播文件、設計和程式碼的變更。結果要麼是限制速度的緩慢、謹慎的更新，要麼是累積技術債務的快速、魯莽的變化。

SDD 可以支援假設/模擬實驗，「如果我們需要重新實作或更改應用程式以促進銷售更多 T 恤的業務需求，我們將如何實作和實驗？」

SDD 將需求變更從障礙轉變為正常工作流程。當規範驅動實作時，轉向成為系統性再生而不是手動重寫。更改 PRD 中的核心需求，受影響的實作計畫會自動更新。修改使用者故事，相應的 API 端點會重新產生。這不僅關乎初始開發——還關乎透過不可避免的變化保持工程速度。

## 核心原則

**規範作為通用語言**：規範成為主要工件。程式碼成為其在特定語言和框架中的表達。維護軟體意味著演進規範。

**可執行規範**：規範必須精確、完整和明確，足以產生工作系統。這消除了意圖和實作之間的差距。

**持續改進**：一致性驗證持續發生，而不是作為一次性關卡。AI 作為持續過程分析規範的模糊性、矛盾和差距。

**研究驅動的上下文**：研究代理在整個規範過程中收集關鍵上下文，調查技術選項、效能影響和組織約束。

**雙向反饋**：生產現實告知規範演進。指標、事件和營運學習成為規範改進的輸入。

**探索性分支**：從同一規範產生多種實作方法，以探索不同的最佳化目標——效能、可維護性、使用者體驗、成本。

## 實作方法

今天，實踐 SDD 需要組裝現有工具並在整個過程中保持紀律。該方法可以透過以下方式實踐：

- 用於迭代規範開發的 AI 助手
- 用於收集技術上下文的研究代理
- 用於將規範轉換為實作的程式碼產生工具
- 適應規範優先工作流程的版本控制系統
- 透過 AI 分析規範文件進行一致性檢查

關鍵是將規範視為真理來源，程式碼作為產生的輸出為規範服務，而不是相反。

## 透過命令簡化 SDD

SDD 方法透過三個強大的命令得到顯著增強，這些命令自動化了規範→計畫→任務工作流程：

### `/specify` 命令

此命令將簡單的功能描述（使用者提示）轉換為完整的結構化規範，並具有自動儲存庫管理：

1. **自動功能編號**：掃描現有規範以確定下一個功能編號（例如，001、002、003）
2. **分支建立**：從您的描述產生語義分支名稱並自動建立
3. **基於模板的產生**：使用您的需求複製和自訂功能規範模板
4. **目錄結構**：為所有相關文件建立適當的 `specs/[branch-name]/` 結構

### `/plan` 命令

一旦功能規範存在，此命令建立全面的實作計畫：

1. **規範分析**：閱讀和理解功能需求、使用者故事和驗收標準
2. **章程合規性**：確保與專案章程和架構原則一致
3. **技術轉換**：將業務需求轉換為技術架構和實作細節
4. **詳細文件**：為資料模型、API 合約和測試場景產生支援文件
5. **快速啟動驗證**：產生捕獲關鍵驗證場景的快速啟動指南

### `/tasks` 命令

計畫建立後，此命令分析計畫和相關設計文件以產生可執行的任務清單：

1. **輸入**：讀取 `plan.md`（必需）以及（如果存在）`data-model.md`、`contracts/` 和 `research.md`
2. **任務推導**：將合約、實體和場景轉換為特定任務
3. **並行化**：標記獨立任務 `[P]` 並概述安全的並行組
4. **輸出**：在功能目錄中寫入 `tasks.md`，準備好由 Task 代理執行

### 範例：建構聊天功能

以下是這些命令如何改變傳統開發工作流程：

**傳統方法：**

```text
1. 在文件中編寫 PRD（2-3 小時）
2. 建立設計文件（2-3 小時）
3. 手動設定專案結構（30 分鐘）
4. 編寫技術規範（3-4 小時）
5. 建立測試計畫（2 小時）
總計：約 12 小時的文件工作
```

**使用命令的 SDD 方法：**

```bash
# 步驟 1：建立功能規範（5 分鐘）
/specify 具有訊息歷史記錄和使用者狀態的即時聊天系統

# 這自動：
# - 建立分支「003-chat-system」
# - 產生 specs/003-chat-system/spec.md
# - 用結構化需求填充它

# 步驟 2：產生實作計畫（5 分鐘）
/plan WebSocket 用於即時訊息傳遞，PostgreSQL 用於歷史記錄，Redis 用於狀態

# 步驟 3：產生可執行任務（5 分鐘）
/tasks

# 這自動建立：
# - specs/003-chat-system/plan.md
# - specs/003-chat-system/research.md（WebSocket 函式庫比較）
# - specs/003-chat-system/data-model.md（訊息和使用者模式）
# - specs/003-chat-system/contracts/（WebSocket 事件，REST 端點）
# - specs/003-chat-system/quickstart.md（關鍵驗證場景）
# - specs/003-chat-system/tasks.md（從計畫派生的任務清單）
```

在 15 分鐘內，您擁有：

- 具有使用者故事和驗收標準的完整功能規範
- 具有技術選擇和基本原理的詳細實作計畫
- 準備好程式碼產生的 API 合約和資料模型
- 自動化和手動測試的綜合測試場景
- 所有文件都在功能分支中正確版本控制

### 結構化自動化的力量

這些命令不僅節省時間——它們強制一致性和完整性：

1. **無遺忘細節**：模板確保考慮每個方面，從非功能性需求到錯誤處理
2. **可追溯決策**：每個技術選擇都連結回特定需求
3. **活文件**：規範與程式碼保持同步，因為它們產生程式碼
4. **快速迭代**：在幾分鐘內更改需求和重新產生計畫，而不是幾天

這些命令透過將規範視為可執行工件而不是靜態文件來體現 SDD 原則。它們將規範過程從必要的邪惡轉變為發展的驅動力。

### 模板驅動的品質：結構如何約束 LLM 以獲得更好的結果

這些命令的真正力量不僅在於自動化，還在於模板如何引導 LLM 行為產生更高品質的規範。模板充當複雜的提示，以生產性的方式約束 LLM 的輸出：

#### 1. **防止過早的實作細節**

功能規範模板明確指示：

```text
- ✅ 專注於使用者需要什麼和為什麼
- ❌ 避免如何實作（無技術堆疊、API、程式碼結構）
```

這種約束迫使 LLM 保持適當的抽象層級。當 LLM 可能自然跳轉到「使用 React 和 Redux 實作」時，模板保持其專注於「使用者需要其資料的即時更新」。這種分離確保規範即使在實作技術發生變化時也保持穩定。

#### 2. **強制明確的不確定性標記**

兩個模板都強制使用 `[NEEDS CLARIFICATION]` 標記：

```text
從使用者提示建立此規範時：
1. **標記所有模糊性**：使用 [NEEDS CLARIFICATION: 具體問題]
2. **不要猜測**：如果提示沒有指定某些內容，請標記它
```

這可以防止 LLM 做出合理但可能不正確的假設的常見行為。LLM 不能猜測「登入系統」使用電子郵件/密碼身份驗證，而是必須將其標記為 `[NEEDS CLARIFICATION: 未指定身份驗證方法 - 電子郵件/密碼、SSO、OAuth？]`。

#### 3. **透過清單進行結構化思維**

模板包含全面的清單，充當規範的「單元測試」：

```markdown
### 需求完整性
- [ ] 沒有 [NEEDS CLARIFICATION] 標記剩餘
- [ ] 需求是可測試和明確的
- [ ] 成功標準是可衡量的
```

這些清單迫使 LLM 系統地自我審查其輸出，捕獲可能遺漏的差距。這就像給 LLM 一個品質保證框架。

#### 4. **透過關卡實現章程合規性**

實作計畫模板透過階段關卡強制執行架構原則：

```markdown
### 階段-1：實作前關卡
#### 簡單性關卡（第七條）
- [ ] 使用 ≤3 個專案？
- [ ] 沒有未來驗證？

#### 反抽象關卡（第八條）
- [ ] 直接使用框架？
- [ ] 單一模型表示？
```

這些關卡透過使 LLM 明確證明任何複雜性來防止過度工程。如果關卡失敗，LLM 必須在「複雜性追蹤」部分記錄原因，為架構決策建立問責制。

#### 5. **分層細節管理**

模板強制執行適當的資訊架構：

```text
**重要**：此實作計畫應保持高層級和可讀性。
任何程式碼範例、詳細演算法或廣泛的技術規範
必須放在適當的 `implementation-details/` 檔案中
```

這可以防止規範成為不可讀的程式碼轉儲的常見問題。LLM 學會保持適當的細節層級，將複雜性提取到單獨的檔案中，同時保持主要文件可導航。

#### 6. **測試優先思維**

實作模板強制執行測試優先開發：

```text
### 檔案建立順序
1. 建立具有 API 規範的 `contracts/`
2. 按順序建立測試檔案：contract → integration → e2e → unit
3. 建立原始檔案以使測試通過
```

這種排序約束確保 LLM 在實作之前考慮可測試性和合約，導致更強大和可驗證的規範。

#### 7. **防止投機性功能**

模板明確阻止投機：

```text
- [ ] 沒有投機性或「可能需要」的功能
- [ ] 所有階段都有明確的先決條件和可交付成果
```

這阻止 LLM 新增使實作複雜化的「很好有」功能。每個功能都必須追溯到具有明確驗收標準的具體使用者故事。

### 複合效應

這些約束一起產生以下特點的規範：

- **完整**：清單確保不會忘記任何內容
- **明確**：強制澄清標記突出不確定性
- **可測試**：測試優先思維融入過程
- **可維護**：適當的抽象層級和資訊層次
- **可實作**：具有具體可交付成果的明確階段

模板將 LLM 從創意作家轉變為紀律嚴明的規範工程師，引導其能力產生始終如一的高品質、可執行規範，真正驅動開發。

## 專案章程基礎：強制執行架構紀律

在 SDD 的核心 lies a constitution——一套不可變的原則，管理規範如何成為程式碼。專案章程（`memory/constitution.md`）充當系統的架構 DNA，確保每個產生的實作保持一致性、簡單性和品質。

### 開發的九條條款

專案章程定義了塑造開發過程各個方面的九條條款：

#### 第一條：函式庫優先原則

每個功能必須作為獨立函式庫開始——沒有例外。這從一開始就強制模組化設計：

```text
Specify 中的每個功能必須作為獨立函式庫開始其存在。
任何功能都不得直接在應用程式碼中實作，
除非首先被抽象為可重用的函式庫元件。
```

這一原則確保規範產生模組化、可重用的程式碼，而不是單體應用程式。當 LLM 產生實作計畫時，它必須將功能構造為具有清晰邊界和最小相依性的函式庫。

#### 第二條：CLI 介面強制要求

每個函式庫必須透過命令列介面公開其功能：

```text
所有 CLI 介面必須：
- 接受文字作為輸入（透過 stdin、參數或檔案）
- 產生文字作為輸出（透過 stdout）
- 支援 JSON 格式進行結構化資料交換
```

這強制執行可觀察性和可測試性。LLM 不能將功能隱藏在不透明的類別中——一切都必須透過基於文字的介面可存取和可驗證。

#### 第三條：測試優先命令

最具變革性的條款——沒有測試就沒有程式碼：

```text
這是不可協商的：所有實作必須遵循嚴格的測試驅動開發。
在之前不得編寫任何實作程式碼：
1. 單元測試已編寫
2. 測試已由使用者驗證和批准
3. 測試確認為失敗（紅色階段）
```

這完全顛覆了傳統的 AI 程式碼產生。LLM 不是產生程式碼並希望它工作，而是必須首先定義行為的綜合測試，獲得它們批准，然後才產生實作。

#### 第七條和第八條：簡單性和反抽象

這些配對條款對抗過度工程：

```text
第 7.3 節：最小專案結構
- 初始實作最多 3 個專案
- 額外專案需要記錄的基本原理

第 8.1 節：框架信任
- 直接使用框架功能而不是包裝它們
```

當 LLM 可能自然建立精心製作的抽象時，這些條款迫使它證明每一層複雜性。實作計畫模板的「階段-1 關卡」直接強制執行這些原則。

#### 第九條：整合優先測試

優先考慮真實世界測試而不是孤立的單元測試：

```text
測試必須使用真實環境：
- 優先使用真實資料庫而不是模擬
- 使用實際服務實例而不是存根
- 實作前的強制合約測試
```

這確保產生的程式碼在實踐中有效，而不僅僅是在理論上。

### 透過模板強制執行專案章程

實作計畫模板透過具體檢查點操作這些條款：

```markdown
### 階段-1：實作前關卡
#### 簡單性關卡（第七條）
- [ ] 使用 ≤3 個專案？
- [ ] 沒有未來驗證？

#### 反抽象關卡（第八條）
- [ ] 直接使用框架？
- [ ] 單一模型表示？

#### 整合優先關卡（第九條）
- [ ] 合約已定義？
- [ ] 合約測試已編寫？
```

這些關卡充當架構原則的編譯時檢查。LLM 無法繼續，除非透過關卡或在「複雜性追蹤」部分記錄證明的例外。

### 不可變原則的力量

專案章程的力量在於其不可變性。雖然實作細節可以演進，但核心原則保持不變。這提供：

1. **時間一致性**：今天產生的程式碼遵循與明年產生的程式碼相同的原則
2. **LLM 一致性**：不同的 AI 模型產生架構相容的程式碼
3. **架構完整性**：每個功能加強而不是破壞系統設計
4. **品質保證**：測試優先、函式庫優先和簡單性原則確保可維護程式碼

### 專案章程演進

雖然原則是不可變的，但它們的應用可以演進：

```text
第 4.2 節：修正過程
對本專案章程的修改需要：
- 變更基本原理的明確文件
- 專案維護者的審查和批准
- 向後相容性評估
```

這允許方法論在學習的同時保持穩定。專案章程顯示其自身的演進，帶有日期修正，展示了如何基於實際經驗完善原則。

### 超越規則：開發哲學

專案章程不僅僅是規則書——它是一種塑造 LLM 如何思考程式碼產生的哲學：

- **可觀察性優於不透明性**：一切都必須透過 CLI 介面可檢查
- **簡單性優於聰明**：從簡單開始，僅在證明必要時新增複雜性
- **整合優於隔離**：在真實環境中測試，而不是人工環境
- **模組化優於單體**：每個功能都是具有清晰邊界的函式庫

透過將這些原則嵌入規範和規劃過程，SDD 確保產生的程式碼不僅是功能性的——它是可維護的、可測試的和架構合理的。專案章程將 AI 從程式碼產生器轉變為尊重和加強系統設計原則的架構夥伴。

## 轉型

這不是關於取代開發者或自動化創造力。這是透過自動化機械轉換來放大人類能力。這是關於建立一個緊密的反饋循環，其中規範、研究和程式碼一起演進，每次迭代都帶來更深的理解和意圖與實作之間更好的對齊。

軟體開發需要更好的工具來保持意圖和實作之間的一致性。SDD 提供了透過產生程式碼而不是僅僅指導程式碼的可執行規範來實現這種一致性的方法論。
