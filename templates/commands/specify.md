---
description: 從自然語言功能描述建立或更新功能規格。
handoffs:
  - label: 建立技術計畫
    agent: speckit.plan
    prompt: 為規範建立計畫。我正在使用...
  - label: 澄清規範需求
    agent: speckit.clarify
    prompt: 澄清規範需求
    send: true
scripts:
  sh: scripts/bash/create-new-feature.sh --json "{ARGS}"
  ps: scripts/powershell/create-new-feature.ps1 -Json "{ARGS}"
---

## 使用者輸入

```text
$ARGUMENTS
```

在繼續之前，你**必須**考慮使用者輸入（如果不為空）。

## 大綱

使用者在觸發訊息中 `/speckit.specify` 之後輸入的文字**就是**功能描述。假設你在此對話中始終可以使用它，即使 `{ARGS}` 在下面按字面顯示。除非使用者提供了空命令，否則不要要求使用者重複。

鑑於該功能描述，執行以下操作：

1. **生成簡潔短名稱**（2-4 個詞）：
   - 分析功能描述並提取最有意義的關鍵詞
   - 建立能捕捉功能精髓的 2-4 個詞短名稱
   - 盡可能使用「動作-名詞」格式（例如："add-user-auth"、"fix-payment-bug"）
   - 保留技術術語和縮寫（OAuth2、API、JWT 等）
   - 保持簡潔但要足夠描述性，讓人一眼就能理解功能
   - 範例：
     - "我想要新增使用者認證" → "user-auth"
     - "為 API 實作 OAuth2 整合" → "oauth2-api-integration"
     - "建立分析儀表板" → "analytics-dashboard"
     - "修復付款處理逾時錯誤" → "fix-payment-timeout"

2. **在建立新分支前檢查現有分支**：

   a. 首先，抓取所有遠端分支以確保我們擁有最新資訊：
      ```bash
      git fetch --all --prune
      ```

   b. 為短名稱找出所有來源中的最高功能編號：
      - 遠端分支：`git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - 本地分支：`git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - 規格目錄：檢查符合 `specs/[0-9]+-<short-name>` 的目錄

   c. 確定下一個可用編號：
      - 從所有三個來源提取所有編號
      - 找出最高編號 N
      - 將 N+1 用於新分支編號

   d. 使用計算出的編號和短名稱執行腳本 `{SCRIPT}`：
      - 傳遞 `--number N+1` 和 `--short-name "your-short-name"` 以及功能描述
      - Bash 範例：`{SCRIPT} --json --number 5 --short-name "user-auth" "新增使用者認證"`
      - PowerShell 範例：`{SCRIPT} -Json -Number 5 -ShortName "user-auth" "新增使用者認證"`

   **重要**：
   - 檢查所有三個來源（遠端分支、本地分支、規格目錄）以找出最高編號
   - 僅匹配具有確切短名稱模式的分支/目錄
   - 如果未找到具有此短名稱的現有分支/目錄，則從編號 1 開始
   - 每個功能只能執行此腳本一次
   - JSON 在終端機中作為輸出提供 - 請務必參考它以取得您要尋找的實際內容
   - JSON 輸出將包含 BRANCH_NAME 和 SPEC_FILE 路徑
   - 對於參數中包含單引號的情況（如 "I'm Groot"），請使用轉義語法：例如 'I'\''m Groot'（或者如果可能，使用雙引號："I'm Groot"）

3. 載入 `templates/spec-template.md` 以了解必需的段落。

4. 遵循此執行流程：

    1. 從輸入解析使用者描述
       如果為空：錯誤「未提供功能描述」
    2. 從描述中提取關鍵概念
       識別：角色、動作、資料、約束
    3. 對於不清楚的方面：
       - 根據上下文和行業標準做出明智的猜測
       - 僅在以下情況下使用 [NEEDS CLARIFICATION: 具體問題] 標記：
         - 選擇顯著影響功能範圍或使用者體驗
         - 存在具有不同含義的多種合理解釋
         - 不存在合理的預設值
       - **限制：最多 3 個 [NEEDS CLARIFICATION] 標記**
       - 按影響優先順序釐清：範圍 > 安全/隱私 > 使用者體驗 > 技術細節
    4. 填寫使用者情境和測試段落
       如果沒有明確的使用者流程：錯誤「無法確定使用者情境」
    5. 生成功能需求
       每個需求必須可測試
       對未指定的細節使用合理的預設值（在假設段落中記錄假設）
    6. 定義成功標準
       建立可衡量的、技術無關的結果
       包括量化指標（時間、效能、數量）和質化措施（使用者滿意度、任務完成）
       每個標準必須可驗證且不包含實作細節
    7. 識別關鍵實體（如果涉及資料）
    8. 回傳：成功（規格準備好進行規劃）

5. 使用範本結構將規格寫入 SPEC_FILE，用從功能描述（參數）導出的具體細節替換佔位符，同時保留段落順序和標題。

6. **規格品質驗證**：寫入初始規格後，根據品質標準驗證它：

   a. **建立規格品質檢查清單**：在 `FEATURE_DIR/checklists/requirements.md` 生成檢查清單檔案，使用檢查清單範本結構，包含這些驗證項目：

      ```markdown
      # 規格品質檢查清單：[功能名稱]

      **目的**：在進入規劃階段之前驗證規格的完整性和品質
      **建立日期**：[日期]
      **功能**：[連結到 spec.md]

      ## 內容品質

      - [ ] 無實作細節（語言、框架、API）
      - [ ] 專注於使用者價值和業務需求
      - [ ] 為非技術利益相關者撰寫
      - [ ] 完成所有必填段落

      ## 需求完整性

      - [ ] 不再保留 [NEEDS CLARIFICATION] 標記
      - [ ] 需求可測試且明確
      - [ ] 成功標準可衡量
      - [ ] 成功標準技術無關（無實作細節）
      - [ ] 定義所有驗收情境
      - [ ] 識別邊緣情況
      - [ ] 範圍清楚界定
      - [ ] 識別依賴項和假設

      ## 功能就緒

      - [ ] 所有功能需求都有清晰的驗收標準
      - [ ] 使用者情境涵蓋主要流程
      - [ ] 功能符合成功標準中定義的可衡量結果
      - [ ] 無實作細節洩漏到規格中

      ## 備註

      - 標記為不完整的項目需要在 `/speckit.clarify` 或 `/speckit.plan` 之前更新規格
      ```

   b. **執行驗證檢查**：根據每個檢查清單項目審查規格：
      - 對於每個項目，確定它是通過還是失敗
      - 記錄發現的具體問題（引用相關規格段落）

   c. **處理驗證結果**：

      - **如果所有項目都通過**：標記檢查清單完成並進入步驟 6

      - **如果項目失敗（排除 [NEEDS CLARIFICATION]）**：
        1. 列出失敗項目和具體問題
        2. 更新規格以解決每個問題
        3. 重新執行驗證直到所有項目通過（最多 3 次迭代）
        4. 如果在 3 次迭代後仍然失敗，在檢查清單備註中記錄剩餘問題並警告使用者

      - **如果保留 [NEEDS CLARIFICATION] 標記**：
        1. 從規格中提取所有 [NEEDS CLARIFICATION: ...] 標記
        2. **限制檢查**：如果存在超過 3 個標記，僅保留 3 個最關鍵的（按範圍/安全/UX 影響），並為其餘做出明智猜測
        3. 對於每個需要釐清的問題（最多 3 個），以此格式向使用者呈現選項：

           ```markdown
           ## 問題 [N]：[主題]

           **上下文**：[引用相關規格段落]

           **我們需要知道的**：[來自 NEEDS CLARIFICATION 標記的具體問題]

           **建議答案**：

           | 選項 | 答案 | 影響 |
           |------|------|------|
           | A    | [第一個建議答案] | [對功能的意義] |
           | B    | [第二個建議答案] | [對功能的意義] |
           | C    | [第三個建議答案] | [對功能的意義] |
           | 自訂 | 提供你自己的答案 | [解釋如何提供自訂輸入] |

           **你的選擇**：_[等待使用者回應]_
           ```

        4. **關鍵 - 表格格式**：確保 markdown 表格格式正確：
           - 使用一致的間距和對齊的管道符號
           - 每個儲存格內容周圍應該有空格：`| 內容 |` 而不是 `|內容|`
           - 標題分隔符至少有 3 個破折號：`|--------|`
           - 測試表格在 markdown 預覽中是否正確渲染
        5. 依序編號問題（Q1、Q2、Q3 - 最多 3 個）
        6. 在等待回應之前一起呈現所有問題
        7. 等待使用者回應所有問題的選擇（例如，「Q1: A, Q2: 自訂 - [詳細資訊], Q3: B」）
        8. 用使用者選擇或提供的答案替換每個 [NEEDS CLARIFICATION] 標記來更新規格
        9. 解決所有釐清後重新執行驗證

   d. **更新檢查清單**：在每次驗證迭代後，更新檢查清單檔案的當前通過/失敗狀態

7. 報告完成情況，包括分支名稱、規格檔案路徑、檢查清單結果，以及下一階段（`/speckit.clarify` 或 `/speckit.plan`）的就緒狀態。

**注意**：腳本在寫入之前建立並檢出新分支並初始化規格檔案。

## 一般指南

## 快速指南

- 專注於使用者需要**什麼**和**為什麼**。
- 避免如何實作（無技術堆疊、API、程式碼結構）。
- 為業務利益相關者撰寫，而非開發人員。
- 不要建立嵌入在規格中的任何檢查清單。那將是一個單獨的命令。

### 段落需求

- **必填段落**：每個功能都必須完成
- **選填段落**：僅在與功能相關時包含
- 當段落不適用時，完全移除它（不要留作「N/A」）

### 用於 AI 生成

從使用者提示建立此規格時：

1. **做出明智的猜測**：使用上下文、行業標準和常見模式來填補空白
2. **記錄假設**：在假設段落中記錄合理的預設值
3. **限制釐清**：最多 3 個 [NEEDS CLARIFICATION] 標記 - 僅用於以下關鍵決策：
   - 顯著影響功能範圍或使用者體驗
   - 有多種合理解釋且含義不同
   - 缺乏任何合理的預設值
4. **優先順序釐清**：範圍 > 安全/隱私 > 使用者體驗 > 技術細節
5. **像測試人員一樣思考**：每個模糊需求都應該無法通過「可測試且明確」檢查清單項目
6. **需要釐清的常見領域**（僅當不存在合理的預設值時）：
   - 功能範圍和邊界（包含/排除特定使用案例）
   - 使用者類型和權限（如果存在多種衝突的解釋）
   - 安全/合規需求（當具有法律/財務重要性時）

**合理預設值的範例**（不要詢問這些）：

- 資料保留：該領域的行業標準做法
- 效能目標：除非另有說明，否則為標準 web/mobile 應用程式期望
- 錯誤處理：使用者友好的訊息和適當的後備
- 身份驗證方法：web 應用程式的標準基於會話或 OAuth2
- 整合模式：除非另有說明，否則為 RESTful API

### 成功標準指南

成功標準必須是：

1. **可衡量**：包括具體指標（時間、百分比、計數、速率）
2. **技術無關**：不提及框架、語言、資料庫或工具
3. **以使用者為中心**：從使用者/業務角度描述結果，而非系統內部
4. **可驗證**：可以在不知道實作細節的情況下測試/驗證

**良好範例**：

- 「使用者可以在 3 分鐘內完成結帳」
- 「系統支援 10,000 個並發使用者」
- 「95% 的搜尋在 1 秒內回傳結果」
- 「任務完成率提高 40%」

**不良範例**（以實作為中心）：

- 「API 回應時間低於 200ms」（過於技術，使用「使用者立即看到結果」）
- 「資料庫可以處理 1000 TPS」（實作細節，使用以使用者為中心的指標）
- 「React 元件有效渲染」（特定於框架）
- 「Redis 快取命中率高於 80%」（特定於技術）
